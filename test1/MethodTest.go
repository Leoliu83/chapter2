package test1

import (
	"fmt"
	"log"
	"reflect"
	"sync"
)

/*
	方法是与对象实例绑定的特殊函数
	方法是面向对象编程的基本概念，用于维护和展示对象的自身状态。
	对象是内敛的,每个实例都有各自不同的独特特征，以属性和方法来暴露对外通信接口。
	普通函数专注于算法流程，通过接收参数来完成特定的逻辑运算，并最终返回结果。
	总结：方法有关联，函数无关联

	如何选择方法的receiver类型：
		·要修改实例状态，用*T
		·无需修改实例状态的*小对象*或固定值，建议用T
		·大对象建议用*T，减少复制成本
		·引用类型，字符串，函数等包含指针的对象，直接用T。
		·若包含Mutex等同步字段的对象，用*T，避免因复制而造成的锁操作无效
		·其他无法确定情况都使用*T
*/
func MethodTest() {
	var a N = 25
	println(a.toString())

	log.Println("*************** Receiver is a (N) ***************")
	a.value()
	a.pointer()
	log.Printf("MethodTest(): %p, %v ", &a, a)

	// 编译器会根据方法 receiver 类型自动在基础类型和指针类型之间进行转化
	log.Println("*************** Receiver is a (Pointer) ***************")
	p := &a
	// 这里的 receiver 变成了指针类型, 在p.value() 接收receiver时，自动转换为值传递
	p.value()
	p.pointer()
	log.Printf("MethodTest(): %p, %v ", &a, a)

	/*
		// 不可以使用多级指针
		p1 := &p
		p1.value() // error
	*/
	// 指针类型的receiver必须是合法指针（包括nil），或能获取实例地址
	// struct receiver
	x1 := X{}
	x1.test()
	// nil receiver
	var x *X
	x.test()
	/*
		// 由于X{}并不是一个合法指针，因此不能直接使用
		// panic: cannot call pointer method test on X
		X{}.test()
	*/

	/*
		匿名字段的方法可以像匿名访问匿名成员那样被调用，由编译器负责查找
		d.Lock() 实际调用的是 func (m *Mutex) Lock() Mutex的Lock()方法
	*/
	d := data{}
	d.Lock()
	d.buf[0] = 1
	d.Unlock()

	/*
		同名方法也存在遮蔽问题，可以实现类似于 override 的功能
	*/
	var p1 parent
	var c1 child
	p1.toString()
	c1.toString()

	/*
		方法集规则：
		·类型T方法集包含所有 receiver T 方法
		·类型*T方法集包含所有 receiver T + *T 方法
		·匿名嵌入S，T方法集包含所有 receiver S 方法
		·匿名嵌入*S，T方法集包含所有 receiver S + *S 方法
		·匿名嵌入S或*S，*T方法集包含所有 receiver S + *S 方法

		下面的实验可以证明，但是输出中可以看到，一些方法的类型发生了改变：
			Name: SPrt,Type: func(*test1.T) <-- 类型发生了改变，不再是 *test1.S
			Name: SVal,Type: func(*test1.T) <-- 类型发生了改变，不再是 *test1.S
			Name: TPrt,Type: func(*test1.T)
			Name: TVal,Type: func(*test1.T)
		通过go tool objdump 可以看到（AReadMe.go中有说明如何使用）：
			TEXT %22%22.(*S).SVal(SB) gofile..<autogenerated>
			TEXT %22%22.(*T).SPrt(SB) gofile..<autogenerated> <-- go编译器按方法集所需生成的包装方法
			TEXT %22%22.(*T).SVal(SB) gofile..<autogenerated> <-- go编译器按方法集所需生成的包装方法
			TEXT %22%22.(*T).TVal(SB) gofile..<autogenerated>
			TEXT %22%22.T.SVal(SB) gofile..<autogenerated>
		这其实就是匿名字段的一个使用场景。
	*/
	var t T
	var s S
	methodSet(t)
	methodSet(&t)
	methodSet(s)
	methodSet(&s)
}

// 可以为当前包中，除接口和指针以外的任何类型定义方法
type N int

/*
	方法有前置实例接收参数(receiver)，也就是这里的'(n N)'，相当于this
	以此来确定方法所属类型。在某些语言里，隐式传递this
*/
func (n N) toString() string {
	log.Println(n)
	return fmt.Sprintf("%#x", n)
}

// 值传递, N 被复制
func (n N) value() {
	n++
	log.Printf("value(): Type %T, Address: %p, Value: %v", n, &n, n)
}

// 指针传递, N没有被复制
func (n *N) pointer() {
	(*n)++
	log.Printf("pointer(): Type %T, Address[*N]: %p, Address[N]: %p,Value: %v", n, &n, n, n)
}

type X struct{}

func (x *X) test() {
	println("hi", x)
}

type data struct {
	sync.Mutex
	buf [1024]byte
}

/*
	方法遮蔽
*/
type parent struct{}

// child的方法会覆盖parent的同名方法
type child struct {
	parent
}

func (p parent) toString() {
	log.Println("parent")
}

func (c child) toString() {
	// 调用父方法
	// c.parent.toString()
	// 自己的方法
	log.Println("child")
}

/* 方法集 Method Set */
type S struct{}
type T struct {
	S
}

// 私有方法集
func (S) sVal()  {}
func (*S) sPrt() {}
func (T) tVal()  {}
func (*T) tPrt() {}

// 公开方法集
func (S) SVal()  {}
func (*S) SPrt() {}
func (T) TVal()  {}
func (*T) TPrt() {}

/*
	该方法只能打印出可导出方法，也就是公开方法（首字母大写的方法）
	NumMethod() 方法版本差异：
	go version 1.6
		returns number of methods
	go version 1.15
		returns number of exported methods
*/
func methodSet(f interface{}) {
	t := reflect.TypeOf(f)
	log.Printf("------------------%T-------------------------", f)
	for i, n := 0, t.NumMethod(); i < n; i++ {
		m := t.Method(i)
		log.Printf("Name: %s,Type: %s", m.Name, m.Type)
	}
}
