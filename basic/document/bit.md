### 位运算
go语言中的位基本运算包括：
与: &
或: |
非: ~
异或: ^
位清空: &^

| 数字  |   定义    |
| :---: | :-------: |
|   0   | false(假) |
|   1   | true(真)  |

#### 数字的二进制表示(假设8位)
##### 正数
正数的二进制表示形式为**原码**
| 十进制 |  二进制   |   反码    |   补码    | 最终二进制表示 |
| :----: | :-------: | :-------: | :-------: | :------------: |
|   5    | 0000 0101 | 0000 0101 | 0000 0101 |   0000 0101    |



##### 负数
负数的二进制表示形式为**补码**
| 十进制 |  二进制   | 反码(除符号位) | 补码(除符号位) | 最终二进制表示 |
| :----: | :-------: | :------------: | :------------: | :------------: |
|   -5   | 1000 0101 |   1111 1010    |   1111 1011    |   1111 1011    |

1. 正数的原码，反码，补码都相同
2. 负数的反码是：除符号位，其余各位取反
3. 负数的补码是：负数的反码+1
4. 正数二进制转原码，直接转
5. 负数二进制转原码，由于是补码形式，因此先转成反码（补码最低位 -1），再转回原码（最高位不变，其余各位取反）

#### '与'运算
##### 符号
``` go
&
```
##### 真值表
|  A值  |  B值  | A & B |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   0   |   1   |   0   |
|   1   |   0   |   0   |
|   1   |   1   |   1   |

##### 特点
1. 有假(0)为假(0)，全真(1)为真(1)

##### 作用
1. 位判断
判断一个数a的二进制形式的第3位是否是1，那么掩码就可以设置为 mask=4(二进制表示就是 100),然后计算: a&4
例如：
  36(0010 0100) & 4(100) = 4(100) 说明第三位是1
  27(0001 1011) & 4(100) = 0(000) 说明第三位是0

2. 位清零
将一个数的第3位清0，那么掩码就可以选择第三位为0其余位为1的数
例如：
  11(1011) & 13(1101) = 9(1001)

3. byte 转 int(其实就是低位不变，高位补0)
将一个byte类型的数字转成int类型，相当于全高位
例如:
   a(byte) & 0xff

4. 判断奇偶性
数字转二进制形式，最后一位如果是1，为奇数，如果是0，为偶数
(a & 1) == 0 <-- 偶数

5. 特定数的取余
当 b 为2的幂时，X % b = X & (b - 1)


#### '或'运算
##### 符号
``` go
|
```
##### 真值表

|  A值  |  B值  | A \| B |
| :---: | :---: | :----: |
|   0   |   0   |   0    |
|   0   |   1   |   1    |
|   1   |   0   |   1    |
|   1   |   1   |   1    |

##### 特点
1. 有(1)为真(1)，全假(0)为假(0)

##### 作用
1. 计算大于某个数的最小的2的幂
``` java
/* 
  这是java的hashmap中的一段代码，就是计算给定数值的最小的2的幂
  因为hashtable的大小必须是2的幂，才可以简化求余操作
  2的幂的二进制形式一定是全1二进制数+1，也就是求一个数的
  例如：
      5 二进制形式为  101
      那么大于5的最小的2的幂就是 7(111) + 1 = 8
  从例子就可以看出，只需要把5的二进制形式的所有位变为1就可以了

  算法步骤，以10为例
  第一步
  int n = 10-1 // 9 即二进制的 0000 1001

  第二步
  n = n | n>>>1   //    0000 1001
                  //  | 0000 0100
                  //  —————————————
                  //    0000 1101

  第三步                  
  n = n | n>>>2   //    0000 1101
                  //  | 0000 0011
                  // —————————————
                  //    0000 1111

  第四步                  
  n = n | n>>>4   //    0000 1101
                  //  | 0000 0011
                  // —————————————
                  //    0000 1111
  
  后续步骤，数值不再变化，所有位都变为1了
*/
static final int MAXIMUM_CAPACITY = 1 << 30;
/**
  * Returns a power of two size for the given target capacity.
  */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

2. 将二进制的指定位设置为1
用一个7bit数字表示一周，一周中的某一天出现特定事件，则置1
例如:
周二出现特定事件，将第2位置一，运算如下
0 | 2 = 2
二进制：
0000 0000 | 0000 0010 = 0000 0010
周五出现特定事件，将第5位置一，运算如下
2 | 16 = 18
二进制：
0000 0010 | 0001 0000 = 0001 0010
最终结果：0001 0010
表示，特定事件出现在一周的第2天和第5天

#### '异或'运算
##### 符号
``` go
^
```
##### 真值表

|  A值  |  B值  | A ^ B |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   0   |   1   |   1   |
|   1   |   0   |   1   |
|   1   |   1   |   0   |

##### 特点
1. 相同为假(0)，不同为真(1)
2. 对一个值做**两次异或操作**，可以获得值本身(a ^ b ^ b = a)

##### 作用
1. 散列运算

2. 变量交换
``` go
a ^= b
b ^= a
a ^= b
```

3. 数据加密
message （原文）
key （秘钥）
cipher_message （密文）
**使用方法：**
message ^ key = cipher_message
cipher_message ^ key = message

```
小知识：
战后，美国数学家香农（Claude Shannon）将他的研究成果公开发表，证明了只要满足两个条件，XOR 加密是无法破解的。
key的长度大于等于message key，且必须是一次性的，且每次都要随机产生。
key必须是一次性的，且每次都要随机产生理由很简单，如果每次的key都是随机的，那么产生的CipherText具有所有可能的值，而且是均匀分布，无法从CipherText看出message的任何特征。也就是说，它具有最大的"信息熵"，因此完全不可能破解。这被称为 XOR 的&amp;quot;完美保密性&amp;quot;（perfect secrecy）。满足上面两个条件的key，叫做 one-time pad（缩写为OTP），意思是"一次性密码本"，因为以前这样的key都是印刷成密码本，每次使用的时候，必须从其中挑选key。
```

4. 数据校验
a ^ b = c
如果a数据丢失，c ^ b == a 可以获得a值

5. 差异比对
a ^ b = 0 (无差异)

#### '右移'运算
##### 符号
``` go
>>> // 无符号右移（golang中无该方式）
>>  // 右移
```
##### 特点
1. 无符号右移：
移动时，将最高位的符号位**作为数字位**一起移动，最高位补0

例：
``` java
-5 >>> 1 // -5 右移一位
```
| 步骤  |      步骤说明      |                  结果                   |
| :---: | :----------------: | :-------------------------------------: |
|   0   | 原始数字（int32）  |                   -5                    |
|   1   |   转成二进制形式   | 1111 1111 1111 1111 1111 1111 1111 1011 |
|   2   |      右移1位       | 01111 1111 1111 1111 1111 1111 1111 101 |
|   3   | 转成十进制（正数） |              2,147,483,645              |
由于最高位是0 ，因此，步骤3以正数形式转换成十进制

1. 右移
移动时，将最高位的符号位**忽略**，移动时，最高位补0，移动完成后，补上原有符号位

例：
``` java
-5 >> 1 // -5 右移一位
```
| 步骤  |      步骤说明      |                  结果                   |
| :---: | :----------------: | :-------------------------------------: |
|   0   | 原始数字（int32）  |                   -5                    |
|   1   |   转成二进制形式   | 1111 1111 1111 1111 1111 1111 1111 1011 |
|   2   |      右移1位       | 11111 1111 1111 1111 1111 1111 1111 101 |
|   3   | 转成十进制（负数） |                   -3                    |
由于最高位是0 ，因此，步骤3以负数形式转换成十进制
也就是先转回反码，再转回原码

#### '清位'运算（golang特有）
##### 符号
``` go
&^
```
##### 特点
1. 将指定位清0

例：
``` java
6 &^ 2 // 将6(0110)的第2位 (0010) 清0
// 结果为 4(100)

6 &^ 4 // 将6(0110)的第3位 (0100) 清0
// 结果为 2(0010)

// 可以看出第几位，不是取决于数字，而是二进制的哪一个bit为1决定
```

```
&^ 可以分解为两步
例如 
6 &^ 2 // 将6(0110)的第2位 (0010) 清0
1. 1101 ^ 0100 = 1001 (将同为1的bit置为0)
2. 1101 & 1001 = 1001
```

