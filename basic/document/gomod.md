##### 介绍
go mod是Go管理依赖关系的方式。

一个模块是一个软件包的集合，这些软件包被发布、版本化，并一起分发。模块可以直接从版本控制库或模块代理服务器上下载。

一个模块由一个模块路径来识别，该路径在go.mod文件中声明，同时还有关于该模块的依赖关系的信息。模块根目录是包含go.mod文件的目录。主模块是包含调用go命令的目录的模块。

一个模块内的每个包是同一目录下的源文件的集合，这些文件被编译在一起。包的路径是与包含包的子目录（相对于模块根目录）相连接的模块路径。例如，模块 "golang.org/x/net "在 "html "目录下包含一个包。那个包的路径是 "golang.org/x/net/html"。

##### 模块路径
模块路径是一个模块的标准名称，在模块的go.mod文件中用模块指令声明。一个模块的路径是该模块内软件包路径的前缀。

一个模块的路径应该描述该模块的作用以及在哪里可以找到它。通常，模块路径由版本库根路径、版本库内的目录（通常为空）和主要版本后缀（仅适用于主要版本2或更高）组成。

仓库根路径是模块路径中与开发模块的版本控制仓库的根目录相对应的部分。大多数模块都定义在其版本库的根目录下，所以这通常是整个路径。例如，golang.org/x/net是同名模块的版本库根目录。关于 go 命令如何使用从模块路径导出的 HTTP 请求来定位版本库的信息，请参见寻找模块路径的版本库。

如果模块没有定义在版本库的根目录中，模块子目录是模块路径中命名目录的部分，不包括主要版本后缀。这也可以作为语义版本标签的前缀。例如，模块golang.org/x/tools/gopls位于根目录golang.org/x/tools的gopls子目录中，所以它的模块子目录是gopls。参见版本与提交的映射和版本库中的模块目录。
如果模块是在主版本2或更高版本发布的，模块路径必须以主版本后缀结尾，如/v2。这可能是也可能不是子目录名称的一部分。例如，路径为 golang.org/x/repo/sub/v2 的模块可能在 golang.org/x/repo 仓库的 /sub 或 /sub/v2 子目录下。

如果一个模块可能被其他模块所依赖，就必须遵循这些规则，以便go命令能够找到并下载该模块。对于模块路径中允许的字符也有一些词法限制。

##### 版本
一个版本标识了一个模块的不可改变的快照，它可能是一个发布版或预发布版。每个版本以字母v开头，后面是语义版本。关于如何对版本进行格式化、解释和比较的细节，请参见Semantic Versioning 2.0.0。

简而言之，语义版本由三个非负整数（major, minor, and patch versions, from left to right）组成，中间用点分开。补丁版本后面可以有一个以连字符开头的可选预发布字符串。预发布字符串或补丁版本后面可以有一个以加号开头的构建元数据字符串。例如，v0.0.0、v1.12.134、v8.0.5-pre和v2.0.9+meta是有效的版本。

版本的每一部分都表明该版本是否稳定，是否与以前的版本兼容。

在对模块的公共接口或文档功能做了向后不兼容的改变后，例如在删除了一个包后，主版本必须被递增，次版本和补丁版本必须被设置为零。
在向后兼容的变化之后，例如增加了一个新的功能之后，次要版本必须被增加，补丁版本必须被设置为零。
补丁版本必须在不影响模块的公共接口的变化之后被递增，例如错误修复或优化。
pre-release后缀表示一个版本是预发布版本。预发布的版本在相应的发布版本之前排序。例如，v1.2.3-pre排在v1.2.3之前。
在比较版本时，构建元数据的后缀被忽略。带有build metadata的标签在版本控制库中被忽略，但build metadata在go.mod文件中指定的版本中被保留下来。后缀+incompatible表示在迁移到模块版本主版本2或更高版本之前发布的版本（见与非模块仓库的兼容性。
如果一个版本的主版本是0，或者它有一个预发布的后缀，则被认为是不稳定的。不稳定的版本不受兼容性要求的限制。例如，v0.2.0 可能与 v0.1.0 不兼容，v1.5.0-beta 可能与 v1.5.0 不兼容。

Go可以在版本控制系统中使用标签、分支或修订版来访问模块，而不遵循这些约定。然而，在主模块中，go命令会自动将不遵循此标准的修订名转换为规范的版本。在这个过程中，go命令也会删除构建元数据的后缀（除了+incompatible）。这可能会产生一个伪版本，一个预先发布的版本，它编码了一个版本标识符（如Git提交哈希值）和一个版本控制系统的时间戳。例如，命令go get -d golang.org/x/net@daa7c041将把提交哈希值daa7c041转换为伪版本v0.0.0-20191109021931-daa7c04131f5。 在主模块之外需要规范的版本，如果go.mod文件中出现类似master的非规范版本，go命令将报告错误。

##### 伪版本
伪版本是一个特殊格式的预发布版本，它对版本控制库中的特定版本信息进行编码。例如，v0.0.0-20191109021931-daa7c04131f5就是一个伪版本。

伪版本可以指那些没有语义版本标签的修订版。它们可以用来在创建版本标签之前测试提交的内容，例如在开发分支上。

每个伪版本都有三个部分。

一个基本的版本前缀（vX.0.0或vX.Y.Z-0），该前缀来自于该修订版之前的语义版本标签，如果没有这样的标签，则是vX.0.0。
一个时间戳（yyyymmddhhmmss），这是修订版创建的UTC时间。在Git中，这是提交时间，而不是作者时间。
修订版标识符（abcdefabcdef），它是提交哈希值的12个字符的前缀，或者在Subversion中，是一个零填充的修订号。
每个伪版本可以是三种形式之一，取决于基础版本。这些形式保证了伪版本比其基本版本高，但比下一个标记的版本低。

vX.0.0-yyyymmddhhmmss-abcdefabcdef在没有已知基础版本时使用。与所有版本一样，主版本X必须与模块的主版本后缀一致。
vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef在基础版本是预发布版本时使用，如vX.Y.Z-pre。
vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef用于基础版本是vX.Y.Z这样的发布版本。例如，如果基础版本是v1.2.3，伪版本可能是v1.2.4-0.20191109021931-daa7c04131f5。
一个以上的伪版本可以通过使用不同的基础版本来引用同一个提交。这发生在写完伪版本后，低版本被标记的时候。

这些形式给了伪版本两个有用的属性。

已知基础版本的伪版本排序高于这些版本，但低于其他预发布的后期版本。
具有相同基本版本前缀的伪版本按时间顺序排序。
go命令进行了一些检查，以确保模块作者能够控制伪版本与其他版本的比较，并确保伪版本指的是实际属于模块提交历史的修订版。

如果指定了一个基本版本，就必须有一个相应的语义版本标签，它是伪版本所描述的修订版的祖先。这可以防止开发者使用比所有标签版本都高的伪版本绕过最小版本选择，例如v1.999.999-9999999999-daa7c04131f5。
时间戳必须符合修订版的时间戳。这可以防止攻击者用不受限制的相同的伪版本充斥模块代理机构。这也可以防止模块消费者改变版本的相对顺序。
修订版必须是模块库的一个分支或标签的祖先。这可以防止攻击者引用未经批准的修改或拉动请求。
伪版本从不需要手工输入。许多命令接受一个提交哈希值或一个分支名称，并将其自动翻译成伪版本（如果有的话，则为标签版本）。比如说

go get -d example.com/mod@master
go list -m -json example.com/mod@abcd

##### Vendoring
当使用模块时，go命令通常通过将模块从源头下载到模块缓存中，然后从这些下载的副本中加载软件包来满足依赖性。vendoring可以用来允许与旧版本的Go互操作，或者确保所有用于构建的文件都存储在一个文件树中。

go mod vendor命令在主模块的根目录下构建一个名为vendor的目录，其中包含主模块中构建和测试包所需的所有包的副本。那些只被主模块外的包测试导入的包不包括在内。与go mod tidy和其他模块命令一样，在构建vendor目录时，除了忽略之外，不考虑其他的构建约束。

go mod vendor也会创建vendor/modules.txt文件，其中包含了一个被vendored软件包的列表，以及它们被复制过来的模块版本。启用 vendoring 时，这个清单被用作模块版本信息的来源，正如 go list -m 和 go version -m 所报告的那样。当 go 命令读取 vendor/modules.txt 时，它会检查模块的版本是否与 go.mod 一致。如果go.mod在vendor/modules.txt生成后发生了变化，go命令将报告一个错误。应再次运行go mod vendor以更新vendor目录。

如果vendor目录存在于主模块的根目录中，如果主模块的go.mod文件中的go版本是1.14或更高，它将被自动使用。要明确地启用vendoring功能，请在调用go命令时使用标志-mod=vendor。要禁止vendoring，使用标志 -mod=readonly 或 -mod=mod。

启用vendoring后，像go build和go test这样的构建命令会从vendor目录中加载软件包，而不是访问网络或本地模块缓存。go list -m命令只打印go.mod中列出的模块信息。go mod命令，如go mod download和go mod tidy，在启用vendoring时没有不同的工作方式，仍然会下载模块和访问模块缓存。 go get在启用vendoring时也没有不同的工作方式。

与在GOPATH模式下不同的是，go命令忽略了主模块根目录以外的供应商目录。此外，由于不使用其他模块中的供应商目录，go命令在构建模块压缩文件时不包括供应商目录（但见已知错误#31562和#37397）。

##### 模块感知的命令
大多数go命令可以在模块感知模式或GOPATH模式下运行。在模块感知模式下，go命令使用go.mod文件来寻找版本依赖，并且它通常从模块缓存中加载软件包，如果缺少模块，则下载模块。在GOPATH模式下，go命令忽略了模块；它在供应商目录和GOPATH中寻找依赖关系。

从Go 1.16开始，无论go.mod文件是否存在，模块感知模式都是默认启用的。在较低的版本中，当当前目录或任何父目录中存在go.mod文件时，模块感知模式被启用。

模块感知模式可以通过GO111MODULE环境变量来控制，该变量可以设置为开、关、或自动。

如果GO111MODULE=off，go命令会忽略go.mod文件，在GOPATH模式下运行。
如果GO111MODULE=on或未设置，则go命令在模块感知模式下运行，即使没有go.mod文件存在。并非所有命令在没有go.mod文件的情况下都能运行：见模块外的模块命令。
如果GO111MODULE=auto，如果当前目录或任何父目录中存在go.mod文件，go命令将以模块感知模式运行。在Go 1.15及更低版本中，这是默认行为。即使没有go.mod文件，go mod子命令和带版本查询的go install也会以模块感知模式运行。
在模块感知模式下，GOPATH 在构建过程中不再定义导入的含义，但它仍然存储下载的依赖项（在 GOPATH/pkg/mod 中；见模块缓存）和安装的命令（在 GOPATH/bin 中，除非设置了 GOBIN）。