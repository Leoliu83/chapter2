#### 类型

##### 类型别名
&emsp;&emsp;类型别名与类型定义不同，例如：
```go
// 类型定义
type myint int64
// 类型别名
type myint = int64
```
类型定义与原始类型不属于同一类型，如果参数是int64类型，不可以传入类型myint的变量。
类型别名与原始类型属于同一类型，如果参数是int64，可以传入类型为myint的变量

类型别名的用处：
1. 重构代码时，可以将旧类型作为类型别名，指向新的类型，新旧代码中使用的新旧类型都会被视为同一类型，对旧代码不会产生影响
2. 

##### go的引用类型
go中的默认引用类型只有：
- 函数（func）
- 切片（slice）
- 字典（map）
- 通道（channel）

##### 10进制小数转2进制小数
整数部分正常转换
小数部分循环乘以2，取整数部分
例如：
100.25
100 转化成二进制为: 0110 0100
0.25 转化成二进制位：01
因此 100.25 的二进制形式为 0110 0100.01

##### 2进制小数转10进制小数
整数部分正常转换
小数部分循环乘以2，取整数部分
例如：
0110 0100.001
0110 0100 转化成10进制为: 100
0.001 转化成10进制位：($0/2^1,0/2^2,1/2^3 → 0.125$) 
因此 0110 0100.001 的二进制形式为 100.125

##### float32类型
###### IEEEE754 标准的32位浮点数（规格化的浮点数）
- 格式：

|  31 |  30 | ... |  23 |  22 | ... |  0  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  S  |     | ... |     |     | ... |     |

- **S (1位)表示符号位**：0正1负
- **23-30 (8位) 表示阶码**：8位以2为底，阶码=阶码真值+127
- **0-22 (23位) 表示尾数**：采用隐含尾数最高位1的表示方法，实际尾数24位，尾数真值 = 1 + 尾数
这种格式的非零浮点数真值为：$(-1)^S×2^{阶码-127}×(1+尾数)$

###### 将10进制32位浮点 转化为 IEEEE754标准的32位浮点数
1. 将10进制转化为2进制
2. 将2进制的非规格化数转化为规格化数
3. 计算移码表示的阶码(偏置值(127)+阶码真值)
4. 以短浮点数格式存储该数
5. 将2进制格式 转成 16进制格式

- 例（100.25）
1. $(100.25)_{10} → (0110 0100.01)_2$
2. $(0110 0100.01)_2 → (1.10010001×2^6)$
3. $(127+6) 0111 1111 + 110 = 10000101$ (6是2的指数)
4. - 符号位：$0$
   - 阶码：$10000101$
   - 尾数：$10010001$ $000 0000 0000 0000$
5. $0 10000101 10010001 000 0000 0000 0000 → 42C8 8000$

**go代码实现**
``` go
f:=100.25
i:=math.Float32bits(f)
s:=fmt.Sprintf("%b",i)
log.Println(s)
```

###### 将IEEEE754标准的32位浮点数 转化为 10进制32位浮点
1. 将16进制格式 转成 2进制格式
2. 分离出“符号位”，“阶码”，“尾数”
3. 计算出阶码真值（阶码-偏置值）
4. 利用上面的结果写出规格化数
5. 将规格化2进制数转化为非规格化2进制数
6. 转换成10进制数，并带上符号位
7. 带上符号位

- 例(C1C90000H)
1. $C1C90000H → 1 10000011 100 1001 0000 0000 0000 0000$
2. - 符号位：$1$
   - 阶码：$10000011$
   - 尾数：$100 1001 0000 0000 0000 0000$
3. 阶码真值：$10000011-1111111=100(4)$
4. 规格化：$1.001001×2^4$
5. 非规格化：$1001.001$
6. 转成10进制：$9.125$
7. 带上符号位：$-9.125$

**go代码实现**
``` go
s := "1000010110010001000000000000000"
i6, _ := strconv.ParseInt(s, 2, 32)
f := math.Float32frombits(uint32(i6))
log.Println(f)
```

##### float64类型
###### IEEEE754 标准的64位浮点数（规格化的浮点数）
- 格式：

|  63 |  62 | ... |  52 |  51 | ... |  0  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  S  |     | ... |     |     | ... |     |

- **S (1位)表示符号位**：0正1负
- **52-62 (11位) 表示阶码**：8位以2为底，阶码=阶码真值+1023
- **0-51 (52位) 表示尾数**：采用隐含尾数最高位1的表示方法，实际尾数24位，尾数真值 = 1 + 尾数
这种格式的非零浮点数真值为：$(-1)^S×2^{阶码-1023}×(1+尾数)$

###### 将10进制64位浮点 转化为 IEEEE754标准的64位浮点数
1. 将10进制转化为2进制
2. 将2进制的非规格化数转化为规格化数
3. 计算移码表示的阶码(偏置值(1023)+阶码真值)
4. 以短浮点数格式存储该数
5. 将2进制格式 转成 16进制格式

- 例（100.25）
1. $(100.25)_{10} → (0110 0100.01)_2$
2. $(0110 0100.01)_2 → (1.10010001×2^6)$
3. $(1023+6) 0011 1111 1111 + 110 = 100 0000 0101$ (6是2的指数)
4. - 符号位：$0$
   - 阶码：$100 0000 0101$
   - 尾数：$10010001$ $0000 00000000 00000000 00000000 00000000 00000000$
5. $0 10000000101 10010001 0000 00000000 00000000 00000000 00000000 00000000 → 4059 1000 0000 0000$

**go代码实现**
``` go
f:=100.25
i:=math.Float64bits(f)
s:=fmt.Sprintf("%b",i)
log.Println(s)
```

###### 将IEEEE754标准的64位浮点数 转化为 10进制64位浮点
1. 将16进制格式 转成 2进制格式
2. 分离出“符号位”，“阶码”，“尾数”
3. 计算出阶码真值（阶码-偏置值(1023)）
4. 利用上面的结果写出规格化数
5. 将规格化2进制数转化为非规格化2进制数
6. 转换成10进制数，并带上符号位

- 例(40591000 00000000)
1. $4059 1000 0000 0000 → 0 10000000101 10010001 0000 00000000 00000000 00000000 00000000 00000000$
2. - 符号位：$1$
   - 阶码：$10000000101$
   - 尾数：$10010001 0000 00000000 00000000 00000000 00000000 00000000$
3. 阶码真值：$10000000101-1111111111=110(6)$
4. 规格化：$1.10010001×2^6$
5. 非规格化：$1100100.01$
6. 转成10进制：$100.25$
7. 带上符号位：$+9.125$

**go代码实现**
``` go
s := "100000001011001000100000000000000000000000000000000000000000000"
i6, _ := strconv.ParseInt(s, 2, 64)
f := math.Float64frombits(uint64(i6))
log.Println(f)
```

###### 非规格化小数
非规格化浮点数（denormalized number,a.k.a. subnormal number）是指的计算机中处理的一类特殊浮点数。在规格化浮点数中，浮点数的尾数不应当包含前导0。如果全部用十进制表示，对于类似0.0123的浮点数，规格化的表示应为1.23e-2。但对于某些过小的数，如1.23e-130，允许的阶数位数不能满足阶数大小的需要，这时可能就会在尾数前添加前导0，如将其表示为0.000123e-126。这时，exp为0

**根据exp的值，浮点精可以被编码三种不同的情况,分别是:**
1. 规格化 exp≠0和≠255 即exp字段不是全为0也不是全为1；
2. 非规格化 exp=0 exp字段全为0；
3. 无穷大 exp=255并且frac=0
4. NaN（不是一个数）exp=255并且frac≠0

对规格化：阶码$E＝e-Bias$,e为exp字段无符号数的值，$Bias=2^{(k-1)}-1=2^{(8-1)}-1=127$,尾数$M＝1+f$,$f$是frac字段的二进制小数,则：
$V=(-1)^s×(1+f)×2^{(e-127)}$

对非规格化：阶码$E＝1－Bias=-126$(这有点违反直觉，正常觉得应该是－Bias，设计者这样设定是为了非规格化平滑过渡到规格化，因为规格化最小值是2^-126),尾数$M＝f$,则:
$V=(-1)^s×(1+f)×2^{(-126)}$

go源码部分解析:
``` go
uvnan    = 0x7FF8000000000001
uvinf    = 0x7FF0000000000000
uvneginf = 0xFFF0000000000000
uvone    = 0x3FF0000000000000
mask     = 0x7FF
shift    = 64 - 11 - 1 // 1位符号位， 11位阶码，52位尾数
bias     = 1023 // 指数偏置
signMask = 1 << 63
fracMask = 1<<shift - 1

func sqrt(x float64) float64 {
	// special cases
	switch {
	// 无穷大，或者本身是NaN 或者等于0  则返回本身
	case x == 0 || IsNaN(x) || IsInf(x, 1):
		return x
	case x < 0:
		return NaN()
	}
	// 将浮点转换为 IEEEE754 浮点二进制（<符号位{1}><阶码(exp){11}><尾数(frac){52}>）
	ix := Float64bits(x)
	// normalize x(规格化的x处理)
	// ix >> shift 剔除尾数，也就是取出了 符号位+阶码（12位）
	// mask:0111 1111 1111  通过和mask做&操作，取出了阶码
	// exp 就是阶码的int值
	exp := int((ix >> shift) & mask)
	// 阶码为0 则
	if exp == 0 { // subnormal x(非规格化的x处理)
		for ix&(1<<shift) == 0 {
			ix <<= 1
			exp--
		}
		exp++
	}
	exp -= bias // unbias exponent
	// 位清除
	ix &^= mask << shift
	ix |= 1 << shift
	if exp&1 == 1 { // odd exp, double x to make it even
		ix <<= 1
	}
	exp >>= 1 // exp = exp/2, exponent of square root
	// generate sqrt(x) bit by bit
	ix <<= 1
	var q, s uint64               // q = sqrt(x)
	r := uint64(1 << (shift + 1)) // r = moving bit from MSB to LSB
	for r != 0 {
		t := s + r
		if t <= ix {
			s = t + r
			ix -= t
			q += r
		}
		ix <<= 1
		r >>= 1
	}
	// final rounding
	if ix != 0 { // remainder, result not exact
		q += q & 1 // round according to extra bit
	}
	ix = q>>1 + uint64(exp-1+bias)<<shift // significand + biased exponent
	return Float64frombits(ix)
}
```