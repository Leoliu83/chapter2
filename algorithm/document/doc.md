#### 算法的定义：
&emsp;&emsp;为了解决某个或者某类问题，需要把指令表示为一定的操作序列，操作序列包括一组操作，每个操作都完成特定的功能，这个就是算法



#### 算法的特性：
##### 输入输出：
- 算法有一个或多个输入
- 算法至少有一个或多个输出

##### 有穷性
&emsp;&emsp;算法在执行有限的步骤后自动结束，不会出现无限，并且每一个步骤都在可以接受的时间内完成

##### 确定性
&emsp;&emsp;算法的每一个步骤都具有确定的含义，不会出现二义性

##### 可行性
&emsp;&emsp;算法的每一个步骤必须是可行的，也就是说，每一步都能够通过有限次数完成

#### 算法设计要求
##### 正确性：
&emsp;&emsp;算法能够正确反映问题的需求、能够得到问题的正确答案

##### 可读性：
&emsp;&emsp;算法设计的目的是便于阅读理解和交流

##### 健壮性：
&emsp;&emsp;当输入数据不合法时，算法也能作出相应的处理，而不是产生异常或者莫名其妙的结果

##### 高效和存储占用低：
&emsp;&emsp;算法应该尽可能满足时间高效，存储量低，但有的时候往往而这不可兼得，因此就需要一个平衡

---

#### 算法效率的度量：
##### 事后统计（不推荐）：
&emsp;&emsp;这种方法主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低

##### 事前统计：
&emsp;&emsp;事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。一个算法好坏的根本在于**算法所采用的策略、方法**以及**问题的输入规模**

###### 例一：
* 算法一
``` go
sum,n := 0,100     // 执行一次
for i:=1;i<=n;i++ { // 执行n+1次（因为当n=100时候，循环还没结束，还必须执行一次 i<n判断，这时n=101，跳出循环）
    sum = sum + i  // 执行n次
}
println(sum)       // 执行一次
```
* 算法二
``` go
sum,n := 0,100  // 执行一次
sum = (1+n)*n/2 // 执行一次
println(sum)    // 执行一次
```
&emsp;&emsp;显然第一种算法，执行了 $1+(n+1)+n+1 = 2n+3$ 次，而第二种算法执行了 $1+1+1=3$ 次。两个算法的第一句和第二句是一样的，因此我们之关心中间的执行部分。如果忽略循环的判断开销，并且把整个循环堪称一个整体，则**算法一**整体执行了**n**次，而**算法二**执行了**1**次

###### 例二
``` go
x,sum,n :=0, 0,100  // 执行一次
for i:=0;i<n;i++ {
    for j:=0;j<n;j++ {
        x++;
        sum = sum + x  // 执行n*n次
    }
}
println(sum) // 执行一次
```
&emsp;&emsp;可以看到这里的例二算法的循环部分整体需要执行$n^2$（忽略循环体头尾开销）次，这明显多余例一中的任何一个算法，而且随着n的增加，执行时间也将远远增加。
可以看到，**最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤**。

---

#### 算法的渐近增长：
假设有A，B，C，D四种算法，他们的输入规模都是n，每一种算法的操作次数分别为：
* A：$2n+3$
* B：$2n$
* C：$3n+1$
* D：$3n$
  
则规模与运算次数的关系如下表：
| $n$ | A（$2n+3$） | B（$2n$） | C（$3n+1$） | D（$3n$） |
| :-:   | :-: | :-: | :-: | :-: |
| 1   | 5   | 2   | 4   | 3   |
| 2   | 7   | 4   | 7   | 6   |
| 3   | 9   | 6   | 10  | 9   |
| 10  | 23  | 20  | 31  | 30  |
| 100 | 203 | 200 | 301 | 300 |

可以看出，当$n=1$时，算法A不如算法C；当$n=2$时，算法A和算法C相当；当$n>2$时，算法A开始优于算法C了，因此算法A整体优于算法C。

##### 渐近增长的定义：
&emsp;&emsp;在输入规模$n$在没有限制的情况下,只要超过一个数值$N$，这个函数的函数值就总是大于另一个函数，那么我们称函数是渐近增长的。

**&emsp;&emsp;函数的渐近增长：给定两个函数$f(n)$和$g(n)$，如果存在一个整数$N$，使得对于所有的$n>N$，$f(n)>g(n)$恒成立，那么我们说$f(n)$的增长 <u>*渐近快于* </u>$g(n)$**

###### 经过测试发现算法函数有如下规则：
* **与最高次项相乘的常数并不重要**
例如 $4n+8$ 和 $2n^2+1$ 两个算法函数相比，即使没有 $n^2$ 前面的常数 $2$ ，前者也远远优于后者。
* **最高次项指数大的，随着规模 $n$ 的增加，结果也会变得增长的特别快**
* **判度一个函数的效率时，函数中的常项和其他次要项常常可以忽略，更应该关注主项（最高阶项）的阶数**

---

#### 算法时间复杂度：
&emsp;&emsp;在进行算法分析时，语句总的执行次数 $T(n)$ ，是基于问题规模的函数，进而分析 $T(n)$ 随 $n$ 的变化情况并确定 $T(n)$ 的数量级。
&emsp;&emsp;算法的时间复杂度也就是算法的时间量度，记作： $T(n) = O(f(n))$ ，它表示随着问题规模 $n$ 的增加，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 $f(n)$ 是问题规模 $n$ 的某个函数。
&emsp;&emsp;用大写的 $O()$ 来体现算法的时间复杂度的记法，称之为**大$O$记法**。
##### 推导大$O$阶：
1. 用常数 $1$ 取代运算中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是$1$,则去除与这个项相乘的常数。
**上面三步操作完成后得到的结果就是大$O$阶**

---

##### 常数阶：
首先是顺序结构的时间复杂度。
``` go
sum,n := 0,100  // 执行一次
sum = (1+n)*n/2 // 执行一次
println(sum)    // 执行一次
```
上面的高斯算法的运行次数函数是 $f(n)=3$。根据推导大$O$法，第一步就是把常数项 $3$ 改为 $1$。并且它没有最高阶项，所以这个算法的时间复杂度为 $O(1)$。
为什么时间复杂度为$1$，因为可以看出，无论n为多少，上面的代码都是执行3次，它与问题的规模$n$无关。这种**与$n$无关，执行时间恒定的算法**，我们称为具有 $O(1)$的时间复杂度，又叫**常数阶**。

##### 线性阶：
``` go
for i:=0;i<n;i++ {
    /*时间复杂度为O(1)的步骤序列*/
}
```
上面这段代码的时间复杂度为$O(n)$，因为循环体中的代码要执行$n$次

##### 对数阶：
```go
count:=1
while (count < n) {
    count = count * 2 
    /*时间复杂度为O(1)的步骤序列*/
}
```
上面的代码，循环的次数为 $\log_2{n}$
假设循环次数是 $x$，每一次循环，count的只就会变成 $2^x$
第 1 次循环：$count=2^1$
第 2 次循环：$count=2^2$
$......$
第 x 次循环：$count=2^x$
$∵ 2^x=n$
$∴ x=log_2{n}$

所以这个循环的时间复杂度为 $O(logn)$

##### 平方阶：
``` go
for i:=0;i<n;i++ {
    for j:=0;j<n;j++ {
        /*时间复杂度为O(1)的步骤序列*/
    }
}
```
在上面这个嵌套循环中，内循环的时间复杂度是$O(n)$，而由于外层的循环，导致内层循环又执行了$n$次，因此上面代码的时间复杂度为$O(n^2)$
如果外层循环改为$m$，则代码的时间复杂度改为 $O(m×n)$
因此可以总结出来，**循环的时间复杂度等于循环体的时间复杂度乘以该循环运行的次数**

下面的循环时间复杂度是多少呢？
``` go
for i:=0;i<n;i++ {
    for j:=i;j<n;j++ {
        /*时间复杂度为O(1)的步骤序列*/
    }
}
```
可以看到，原本是**j:=0**变为了**j:=i**，也就是每次内层循环的次数由$n$变成了$n-i$，所以上面代码的执行次数为：
$n+(n-1)+(n-2)+\cdots+1$
$= \frac{n×(n+1)}{2}$
$= \frac{n^2}{2}-\frac{n}{2}$
按照推导大$O$阶的方法，最终得到这段代码的时间复杂度为$O(n^2)$

##### 常见的时间复杂度：
| 执行次数函数 | 阶 | 非正式术语 | 耗费时间排名<br/>（越小耗时越少） |
| :-: | :-: | :-: | :-: |
| $12$ | $O(1)$ | 常数阶 | $1$ |
| $5log_2{n}+20$ | $log_2{n}$ | 对数阶 | $2$ |
| $2n+3nlog_2{n}+19$ | $nlog_2{n}$ | nlog阶 | $4$ |
| $2n+3$ | $O(n)$ | 线性阶 | $3$ |
| $3n^2+2n+1$ | $O(n^2)$ | 平方阶 | $4$ |
| $6n^3+2n^2+3n+4$ | $O(n^3)$ | 立方阶 | $5$ |
| $2^n$ | $O(2^n)$ | 指数阶 | $6$ |
一般来说 $O(2^n)$ 、$O(n^n)$ 和 $O(n!)$ 算法时间复杂度都是噩梦般的，因此在实际情况中，我们都不与考虑。这三种时间复杂度消耗的时间为：$O(2^n)<O(n!)<O(n^n)$

#### 最坏情况与平均情况：
&emsp;&emsp;我们查找一个有n个数字的数组中的某个数字，按照顺序查找，最好的情况就是第一个元素就是我们要找的值，最坏的情况是我们要找的值是最后一个元素。
&emsp;&emsp;**最坏情况运行时间**是一种保证，也就是情况不能再坏了。在应用中这是一种最重要的需求，一般我们提到的运行时间都是**最坏情况**的运行时间。
&emsp;&emsp;**平均情况运行时间**是所有情况中最有意义的，因为它是期望的运行时间。

---

#### 算法空间复杂度
&emsp;&emsp;算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：$S(n)=O(f(n))$，其中，$n$是问题的规模，$f(n)$是语句关于n所占存储空间的函数。

---

###### doc编写使用的vscode库：
* Markdown All in One
* Markdown Preview Enhanced
* Markdown+Math