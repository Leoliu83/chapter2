#### <center>线性表的链式存储结构</center>
##### 顺序存储结构不足的解决办法
&emsp;&emsp;让每个元素知道每个元素所在的位置，这样就不需要让所有的元素都在一起，每个元素可以在内存中的任意位置，只要第一个元素能够通过地址找到它的后一个元素即可。

---

##### 线性表链式存储结构的定义
&emsp;&emsp;为了表示每个元素$a_i$与其直接后继元素$a_{i+1}$之间的逻辑关系，对数据元素$a_i$来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或者链。这两部分信息组成数据元素$a_i$的存储映像，称为节点（Node）。
&emsp;&emsp;n个节点（$a_i$的存储映像）链结成一个链表，即为线性链表（$a_i, a_2, \cdots, a_n$）的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做**单链表**。
&emsp;&emsp;我们把链表中得第一个节点的存储位置叫做**头指针**。
&emsp;&emsp;为了方便对链表进行操作，我们会在第一个节点（头指针）前附设一个节点，称之为**头结点**

---

##### 头指针与头结点的异同
|头指针|头结点|
| :--: | :--: |
|头指针是指链表指向第一个及诶点的指针，若链表有头结点，则是指向头结点的指针|头结点是为了操作的统一和方便而设立的，放在第一元素的节点之前，其数据域一般无意义（也可存放链表长度）|
|头指针具有标识作用，所以常用头指针冠以链表的名字|有了头结点，对第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了|
|无论链表是否为空，头指针均不为空。头指针是链表的必要元素|头结点不一定是链表的必须要素|

---

##### 单链表的存储结构代码描述
```c
/*线性表的单链表存储结构*/
typedef struct Node{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList; /*定义LinkList*/
```
节点由存放数据元素的**数据域**和存放后继节点地址的**指针域**组成

##### 单链表的读取
获取链表第i个数据的算法思路：
1. 声明一个节点p指向链表第一个节点，初始化j从1开始；
2. 当$j<i$时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j++；
3. 若到链表末尾为空，则说明第i个元素不存在；
4. 否则查找成功，返回节点p的数据

代码详见：linkedlist.go

说白了就是从第一个位置开始找，一直找到第i个位置，由于这个算法的时间复杂度取决于i的位置，按照**最坏情况**来说，算法需要运行$n-1$次，因此该算法的时间复杂度为$O(n)$

##### 单链表的插入与删除
###### 单链表的插入
单链表第i个数据插入结点的算法思路：
1. 声明一结点p指向链表第一个节点，初始化j从1开始
2. 当$j<i$时，就遍历链表，让p的指针向后移动，不断指向下一节点，j++
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，在系统中生成一个空节点s； Use: malloc(sizeof(Node))
5. 将元素e赋值给s->data
6. 单链表的插入标准语句 s->next=p->next; p->next=s
7. 返回成功

代码详见：linkedlist.go


###### 单链表的删除
单链表第i个数据删除结点的算法思路：
1. 声明一结点p指向链表第一个节点，初始化j从1开始
2. 当$j<i$时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j累加1
3. 若到链表末尾p为空，则说明第i个元素不存在
4. 否则查找成功，将欲删除的结点p->next赋值给q；
5. 单链表的删除标准语句p->next = q->next
6. 将q结点中得数据赋值给e，作为返回；
7. 释放q结点
8. 返回成功

代码详见：linkedlist.go

---

##### 单链表的整表创建
单链表整表创建的算法思路：
1. 声明一结点p和计数器变量
2. 初始化一空链表L；
3. 让L的头结点的指针指向NULL,即建立一个带头结点的单链表
4. 循环：
   * 生成一新结点赋值给p
   * 随机生成一数字赋值给p的数据域p->data
   * 将p插入到头结点与前一结点之间。

代码详见：linkedlist.go

---

##### 单链表的整表删除
单链表整表删除的算法思路：
1. 声明一结点p和q
2. 将第一个节点赋值给p
3. 循环：
   * 将下一个节点赋值给q
   * 释放p
   * 将q赋值给p

代码详见：linkedlist.go

---

##### 单链表结构与顺序存储结构的优缺点
* 存储分配方式
  * 顺序存储结构: 用一段连续的存储单元，依次存储线性表中的数据元素
  * 单链表: 采用链式存储结构，用一组任意的存储单元存放线性表元素
* 时间性能
  * 查找
    * 顺序存储结构: $O(1)$
    * 单链表: $O(n)$
  * 插入和删除
    * 顺序存储结构: 需要平均移动表长一半的元素，时间为 $O(n)$
    * 单链表: 单链表在线找出某位置$O(n)$的指针后，插入和删除时间为 $O(1)$
* 空间性能
  * 顺序存储结构: 需要预分配存储空间，分配大了容易造成空间浪费
  * 单链表: 不需要预分配存储空间，只要有空间，元素个数也不受限制

##### 总结：
* 如果线性表要频繁的查找，很少的删除和插入，则建议使用线性存储结构
* 如果线性表需要频繁的插入和删除，则建议使用单链表结构。
* 线性表中如果元素变化较大，无法确定元素数量有多大的时候，建议使用单链表结构
* 如果事先知道长度，例如一年12个月，一周7天，这种建议使用顺序存储结构。
