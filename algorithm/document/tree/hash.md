##### (n - 1) & hash
这个是java的hashmap中的经典取余操作
但是有个前提就是  n必须是2的幂

**回顾一下什么是取余**
例如：
$ 100 ÷ 8 $
**首先：**
可以先将100拆成两部分 $100 = 96 + 4$
96 是可以被8整除的部分
4 是不可以被8整除的部分
因此就得到了余数为4

**其次：**
可以被8整除的数有什么特征，不知道的话，反过来想一下
一个数乘以8，是个整数，这个数的二进制形式有什么特征
在计算机里，一个数乘以2，相当于位操作的左移
举个例子：
$9×2=18$
9的二进制形式是： 1001
18的二进制形式是：1001 0
$9×2×2=36$
36的二进制形式是：1001 00
$9×2×2×2=72$
72的二进制形式是：1001 000
所以，$9×8=72$就是把9左移3位
这种算法的前提是，乘数必须是2的幂
那么8又是什么？
8的二进制形式为：1000
其实8就是把1左移3位

那么反过来$72÷8=9$就是将72右移3位
说明72的最后3位一定是0
72的二进制形式是：1001000
右移3位就是：1001 也就是：9
上面就是除法除以2的幂的二进制操作


下面说余数
$72 ≡ 0\text{ (mod 8)}$
表示$72÷8=9...0(余数)$
看看73的情况
$73 ≡ 1\text{ (mod 8)}$
73的二进制形式是：1001 001
$79 ≡ 7\text{ (mod 8)}$
79的二进制形式是：1001 111
80的话就是8的倍数，因此余数为0
所以可以看到，可以看成$72+7=(9×8)+7$
也就是 1001（9）左移3位加 111（7）
在看79的二进制形式

```
1001 111
  ↑   ↑   
  9   7
```
可以看到，一个数A，对8求余，其实就可以看做把A的二进制形式拆成两个部分，**最后3位**是余数，除了最后3位的所有位为商
再举个例子
计算：$20÷8$
先把20写成二进制形式为：10100
然后分成两部分：后3位，和除了后3位的其他位
```
10 100
 ↑  ↑
 2  4   
```
所以$20÷8$的结果就是：商2余4
为什么是**最后3位**，因为8是1左移**3位**得到的

那如果是除以16呢？
因为16是1左移**4位**得到的，因此一个数A对16求余，就应该是吧A的二进制形式拆成两个部分，**最后4位**是余数，除了最后4位的所有位为商

所以，求余就变成了取一个数的二进制形式的最后N位
如何取一个数的低N位，我们就想到了逻辑与（&）
'&'真值是，有0为0，同1为1
1和0 与 0 都是0
只有1 与 1 才是1
所以要取最后3位，只需要把这个数和 00000000000000111 做逻辑与操作，那么除了最后3位，其他位都变成了0，最后3位会按原本显示。
00000000000000111 中的前置的0可以不写，也就是111，二进制的111就是7（8-1）
那要取最后4位，就是与 1111 做逻辑与操作，二进制的 1111 就是15（16-1）

**所以到一般情况就是：**
$如果一个数A对一个数n求余，那么其实就是这个数A和n-1做逻辑与\text{(\&)}操作，但前提是，n必须是2的幂$

这就是 hash 对 n 求余，在n是2的幂的前提下，可以写成 (n - 1) & hash 的原因了